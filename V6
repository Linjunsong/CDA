#include <TROOT.h>
#include <TCanvas.h>
#include <TSystem.h>
#include <TFile.h>
#include <TObject.h>
#include <TString.h>
#include <iostream>
#include <sstream>
#include <string>

#include <TMath.h>
#include <TF1.h>
#include <TF3.h>
#include <TGraph.h>
#include <TGraphPainter.h>
#include <TAxis.h>
#include <TH1.h>
#include <TF1.h>
#include <TRandom3.h>
//#include "TSpline.h"

#include "TCPRecord.h"
#include "TCPulse.h"
#include "TCEvent.h"
#include "TCEventList.h"
#include "TCException.h"
#include "TCAnalysisInfo.h"
#include "TCRun.h"
#include "TArrayD.h"
#include "TCMainEventData.h"
#include "TCDaqInfo.h"
#include "TCCryoProcessInfo.h"
#include "TPaveStats.h"
#include "TStyle.h"
#include "TMinuit.h"

using std::cout;
using std::endl;

Double_t Base;

void GetParametersv5(TArrayI &arr, TCParContainer *par)
{
  if (par == 0) throw TCException(TCException::kNoParContainer);
  TCParameter::EParameterType tp = TCParameter::kPulse;
  arr.Set(32);
  arr[0] = par->GetNewParameter("Pulse Number", kTRUE, tp);
  arr[1] = par->GetNewParameter("Baseline Offset [V] v5", kTRUE, tp);
  arr[2] = par->GetNewParameter("Pulse Height [V]", kTRUE, tp);
  arr[3] = par->GetNewParameter("Peak Position [ms]", kTRUE, tp);
  arr[4] = par->GetNewParameter("Peak Onset [ms]", kTRUE, tp);
  arr[5] = par->GetNewParameter("Risetime (10-50) [ms]", kTRUE, tp);
  arr[6] = par->GetNewParameter("Risetime (10-70) [ms]", kTRUE, tp);
  arr[7] = par->GetNewParameter("Decaytime [ms]", kTRUE, tp);
  arr[8] = par->GetNewParameter("Baseline Sample [V]", kTRUE, tp);                                  ////    ??????????
  arr[9] = par->GetNewParameter("Right - Left Baseline [V]", kTRUE, tp);                            ////    ??????????
  arr[10] = par->GetNewParameter("FWHM of Baseline [V]", kTRUE, tp);                                ////    ??????????
  arr[11] = par->GetNewParameter("Plain FWHM of Baseline [V]", kTRUE, tp);
  arr[12] = par->GetNewParameter("Trigger Delay [ms]", kTRUE, tp);                                  ////    ?????????  Difference and relationship to the Peak Onset??
  arr[13] = par->GetNewParameter("Integral over PH [ms]", kTRUE, tp);                               ////    Integral divided over pulse height
  arr[14] = par->GetNewParameter("Dead Time [h]", kTRUE, tp);
  arr[15] = par->GetNewParameter("Live Time [h]", kTRUE, tp);
  arr[17] = par->GetNewParameter("Baseline Gradient [V/ms]", kTRUE, tp);
  arr[18] = par->GetNewParameter("Pile-up Voltage / RMS", kTRUE, tp);
  arr[19] = par->GetNewParameter("Pile-up Time Width [ms]", kTRUE, tp);
  arr[20] = par->GetNewParameter("Baseline RMS [V]", kTRUE, tp);
  arr[22] = par->GetNewParameter("Minimum Voltage [V]", kTRUE, tp);                                 // ????????????????????
  arr[23] = par->GetNewParameter("Maximum Voltage [V]", kTRUE, tp);                                 // ????????????????????
  arr[25] = par->GetNewParameter("Offset [ms]", kTRUE, tp);     // ??????????????????? Difference in the transition time point of positive and negative pulse
  arr[26] = par->GetNewParameter("Period [ms]", kTRUE, tp);
  arr[27] = par->GetNewParameter("RMS of Period [ms]", kTRUE, tp);
  arr[28] = par->GetNewParameter("RMS of Offset [ms]", kTRUE, tp);
  arr[29] = par->GetNewParameter("RMS of Std Baseline", kTRUE, tp);             // Std Baseline?          ???????????????
  arr[30] = par->GetNewParameter("NTD Resistance", kTRUE, tp);
  arr[31] = par->GetNewParameter("Pulse Height [keV]", kTRUE, tp);
}

//Below Junsong try to get the baseline of the raw data(different from baseline of the demodulated data) from an average of n periods (n may be a reasonably small period), with the smallest RMS. By scanning the whole event in it, we should get a more precise baseline than just averaging out in the dyfunctional pretrigger region(seems to be the first half of the event here). If a pulse happens to be in the pretrigger region, the pulse may poinson the baseline if we use the old baseline method and leave us with a less precise baseline. 
Double_t GetBase(TArrayD y)
{
  TArrayD av; // the averaged value of one period
  Int_t an=0; //averaged value number
  Int_t n=10;  //n stands for the number of periods we try to average out.
  Int_t l=1;
  Int_t f=0;  //How many times it flipped around 0
  Double_t k=0.0;
  Double_t sum=0.0;
  while(y[l]*y[l-1]>0) l++;  //get to the start point, those data points before the first transition point are disposed.

  for(Int_t j=l;j<y.GetSize();j++)
  { 
    sum = sum + y[j];
    k++;
    if (y[j]*y[j-1]<=0) 
    {
      if (y[j]!=0)
      f++;

      else
      {
       f++;
       j++;    //To avoid that y[j]==0
      }
    }

    if (f==2)
    {
    an++;
    av.Set(an);
    av[an-1]=sum/k;

    sum=0.0;  //return to zero
    k=0.0;
    f=0;
    }
  }

    Int_t basestart(1), basei(0);
    Double_t rmsbase(10), rmsi(0), baseavg(0), avgi(0);

    while ((basei + n-1)<an)
    {
      for(Int_t i=basei; i<=(basei+n-1); i++) avgi += av[i];
      avgi /= n;
      rmsi = 0;
      for(Int_t i=basei; i<=(basei+n-1); i++) rmsi += (av[i]-avgi)*(av[i]-avgi);
      rmsi /= n;
      rmsi = TMath::Sqrt(rmsi);
      if (rmsi < rmsbase)
      {
	basestart = basei;
	rmsbase = rmsi;
	baseavg = avgi;
      }
      basei++;
      avgi=0.0;
    }
    return baseavg;
}

void Period(TCPulse pls, TArrayI pmap, Int_t DetNum, Double_t  &per, Double_t  &off)
{
  TCAnalysisInfo * ana = gRun->GetAnalysisInfo(DetNum, TCVirtualEvent::kPulseCollection);
  if (ana == 0) throw TCException(TCException::kNoAnalysisInfo);
  TCDaqInfo* daq = ana->GetDaqInfo();
  if (daq == 0) throw TCException(TCException::kNoDaqInfo);
//  TCCryoProcessInfo* cryo = ana->GetCryoProcessInfo();

  Double_t  timbas = 0.001 * daq->GetTimeBase(); // now in milli-seconds. It was in the unit of micro-second
  Int_t recl(0), posMaximum(0);
  Double_t  baseline(0), maxPos(1), maximum(-10), minimum(10);
  TArrayD y; // this will be filled with the data points of each pulse

  pls.GetTDData(y, baseline);       

  recl = pls.GetRecordLength();

  /////////////////////////////////////////////////////////////////////////////////////////////
  //
  //  Find the period of modulation and offset of the switching of the signal
  //
  /////////////////////////////////////////////////////////////////////////////////////////////

    // Find the maximum of the original pulse and its peak position.
    // This will be used to define a cutoff value and trigger on the spikes at each switch

    Int_t searchThatFar(recl);
    Double_t maximumold (10);
    for (Int_t i=0; i<searchThatFar; ++i)
    {
      if ((y[i] > maximum)&&(y[i] < maximumold))
      {                                           //Why do we need to consider "&&(y[i] < maximumold)" Philip: maybe from old code, reason unknown
	maximum = y[i];
	posMaximum = i;
      }
      if (y[i] < minimum)
      {
	minimum = y[i];
      }
    }
    maxPos = double(posMaximum);
    maxPos *= timbas;

    Base = GetBase(y);
    // Define two cutoff values, one at the half maximum in the positive region,
    // and the other in the negative region.1419
    //    cout << "Base = " << Base << "   maximum = " << maximum << endl;
    Double_t  cutoffp = (Base+0.3*(maximum-Base));
    Double_t  cutoffn = (Base+0.3*(minimum-Base));
    Double_t  cutoffp2 = (Base+0.001*(maximum - Base));
    Double_t  cutoffn2 = (Base+0.001*(minimum - Base));

    Int_t nmax(100000);
    TArrayI arri; // array of 'i' values at switch
    arri.Set(nmax);           //TArray.Set defines number of entities in the Array

    Bool_t Positive(kTRUE);   // indicate whether the data point is in the positive half or negative half.
    Int_t ntemp(0);
    for (Int_t i=0; i<searchThatFar; i++)
    {
       if(ntemp < nmax)
       {
	  if ((Positive == kTRUE) && (y[i] > cutoffp))

//It seems to me that here it over counts?Because for example in a positive side, there are many points over the cutoffp value. So each time it counts a arri[ntemp], which is not what we want. We want that each transition count once. Philip answer: it will flip to Positive = kFALSE and it will not count any more. So no problem here.
        
          { // find the rough location using the first cut off
	     if (i ==  0) Positive = kFALSE;//ignore anything that occurs at the beginning of the pulse Alternative solution, the for sequence, i starts from Int_t i=1;
	     else 
             {
	        for (Int_t j=i; j>=0; --j)
                { // work backwards using raw data to find the onset. But this the y-axis value of this onset point may be larger or smaller than the baseline
	         arri[ntemp] = j;
	         if (y[j] < cutoffp2) break;
	        }
	         Positive = kFALSE;
	         ntemp++;
	     }
	  }

          if ((Positive == kFALSE) && (y[i] < cutoffn))
          { // do the same for negative spikes
	      if (i == 0) Positive = kTRUE;
	      else 
              {
	        for (Int_t j=i; j>=0; --j)
                {
	        arri[ntemp] = j;
	        if (y[j] > cutoffn2) break;
	        }
	        Positive = kTRUE;
	        ntemp++;
	      }
	  }
       }
    }

    if (ntemp <= 1)//This condition states that there is no modulation or only modulation through one positive or just one negative side. Not enough to talk about period.
    {
      per = 0;
      off =0;
    }

    else
    {
      // Calculate the period and the offset using these switching positons
      per = (arri[ntemp-1]-arri[0])*timbas/(ntemp-1);// the period defined here with these switching points correspond to only half of the real periods.
      off = 0;
      for (Int_t i=0; i<ntemp; i++)  off += arri[i]*timbas - i*per;
      off = off/(ntemp);
    }

    // Calculate the rms of the period
    Double_t rmsper(0.0);
    for (Int_t i=1; i<ntemp; ++i) 
    {
      const Double_t brak = (arri[i]-arri[i-1])*timbas - per;
      rmsper += (brak * brak);
    }
    rmsper /= double(ntemp - 1);
    rmsper = sqrt(rmsper);
    // and the rms of the offset - these may be useful in identifying unstable pulses
    Double_t rmsoff(0.0);
    for (Int_t i=0; i<ntemp; ++i) 
    {
      const Double_t brak = arri[i]*timbas - i*per - off;
      rmsoff += (brak * brak);
    }
    rmsoff /= double(ntemp);
    rmsoff = sqrt(rmsoff);

    //    if (y[0] > cutoffp) off += per;
    //    if (off < 0) off += 2*per;
    //    if (off < 0) off += per;
    if (y[Int_t(off/timbas+0.2*per/timbas)]>cutoffp2) off +=per; //It makes the off set always is the switching from positive to negative edge. 
    //    while (off > 2*per) off -= per;
    pls.SetParameterValue(off, pmap[25]);
    pls.SetParameterValue(2.0*per, pmap[26]);
    pls.SetParameterValue(rmsper, pmap[27]);
    pls.SetParameterValue(rmsoff, pmap[28]);


}


void GetPeriod(TString DetName, TString EventList)
{
  Int_t DetNum = gRun->GetAnalysisInfoNumber(DetName,TCVirtualEvent::kPulseCollection);

  //  Start by getting the analysis and DAQ infos
  TCAnalysisInfo * ana = gRun->GetAnalysisInfo(DetNum,TCVirtualEvent::kPulseCollection);
  if (ana == 0) throw TCException(TCException::kNoAnalysisInfo);  
  TCDaqInfo* daq = ana->GetDaqInfo();
  if (daq == 0) throw TCException(TCException::kNoDaqInfo);
  TCEventList *List = gRun->GetEventList(EventList);
  //  if (List == 0) throw TCException (TCException::kNoEventList);
  TCParContainer* pc = gRun->GetParContainer(TCVirtualEvent::kPulseCollection);

  TCEventListIter eit(List);
  TCEvent *e(0);
  TArrayI pmap;           // Array for mapping parameters
  GetParametersv5(pmap, pc);

   while ((e = static_cast<TCEvent*>(eit.Next()))) 
   {
//    cout << "Event  " << e->GetEventNumber() << endl;
    TCPulse pls;
    e->GetPulse(pls,DetNum);
    Double_t  per(0), off(0); // period and offset of the switching

    // Find the period and offset of the switching and process each pulse
    Period(pls, pmap, DetNum, per, off);
   }
}

void Mainv6(TString DetName, TString EventList, Bool_t hp, Double_t Vs, TString fname)  //hp indicates whether high pass is desired, becauese highpass consumes a lot of computing time, Vs is the square wave voltage. 
{
  Int_t DetNum = gRun->GetAnalysisInfoNumber(DetName,TCVirtualEvent::kPulseCollection);

  TCAnalysisInfo * ana = gRun->GetAnalysisInfo(DetNum,TCVirtualEvent::kPulseCollection);
  if (ana == 0) throw TCException(TCException::kNoAnalysisInfo);
  TCDaqInfo* daq = ana->GetDaqInfo();
  if (daq == 0) throw TCException(TCException::kNoDaqInfo);
  TCEventList *List = gRun->GetEventList(EventList);
  if (List == 0) throw TCException (TCException::kNoEventList);

  Double_t  timbas = 0.001 * daq->GetTimeBase(); // now in unit of milli-second. It was in the unit of micro-seconds
  TCParContainer*  pc = gRun->GetParContainer(TCVirtualEvent::kPulseCollection);
  TCEventListIter eit(List);
  TCEvent *e(0);
  TArrayI pmap;           // Array for mapping parameters
  GetParametersv5(pmap, pc);


  Int_t pno(0); //pno stands for number of pulse for the analysis without any cuts
  Int_t pno2(0); //pno 2 stands for the pulse number after the baseline gradient in the long event
  Int_t pno3(0); //pno 3 stands for the pulse number after the pile up parameter cut in the long event
  Int_t pno4(0);
  Int_t pno5(0);
  Int_t pno6(0);
  Int_t pno7(0);
  Int_t pno8(0);
  Int_t pno_f(0);

  TArrayD long_event;//the container for the long event list

  TArrayD pheights; //pheights stands for pulse height
  TArrayD pheights2; 
  TArrayD pheights3; 
  TArrayD pheights4; 
  TArrayD pheights5; 
  TArrayD pheights6; 
  TArrayD pheights7; 
  TArrayD pheights8; 
  TArrayD pheights_f; 
  TArrayD pheights_f2;

  TArrayD risets; //risets stands for rise time
  TArrayD risets2; 
  TArrayD risets3;
  TArrayD risets4;
  TArrayD risets5;
  TArrayD risets6;
  TArrayD risets7;
  TArrayD risets8;
  TArrayD risets_f;

  TArrayD decayts; //decay times 
  TArrayD decayts2;
  TArrayD decayts3;
  TArrayD decayts4;
  TArrayD decayts5;
  TArrayD decayts6;
  TArrayD decayts7;
  TArrayD decayts8;
  TArrayD decayts_f;
  TArrayD decayts_t;

  TArrayD times; //the absolute time of the pulse in the event
  TArrayD times2;
  TArrayD times3;
  TArrayD times4;
  TArrayD times5;
  TArrayD times6;
  TArrayD times7;
  TArrayD times8;
  TArrayD times_f;

  TArrayD bRMS; //the baseline RMS container of each event, it is known to be underestimated the true value
  TArrayD b_RMS; //the baseline RMS container of prerigger region of each pulses in long event analysis
  TArrayD b_RMS2;
  TArrayD b_RMS3;
  TArrayD b_RMS4;
  TArrayD b_RMS5;
  TArrayD b_RMS6;
  TArrayD b_RMS7;
  TArrayD b_RMS8;
  TArrayD b_RMS_f;

  TArrayD PSR; //pulse start resistance. Actually it is not the resistance, because of the demodulation process and the exponential shape fo the raw data. But it is a related parameter
  TArrayD PSR2;
  TArrayD PSR3;
  TArrayD PSR4;
  TArrayD PSR5;
  TArrayD PSR6;
  TArrayD PSR7;
  TArrayD PSR8;
  TArrayD PSR_f;
  TArrayD PSR_c;//after chisquare cut

  TArrayI ntime; //peak location in the long event
  TArrayI ntime2;
  TArrayI ntime3;
  TArrayI ntime4;
  TArrayI ntime5;
  TArrayI ntime6;
  TArrayI ntime7;
  TArrayI ntime8;
  TArrayI ntime_f;

  TArrayD RD; //ratio of difference, used in pile up cut
  TArrayD RD2;
  TArrayD RD3;
  TArrayD RD4;
  TArrayD RD5;
  TArrayD RD6;
  TArrayD RD7;
  TArrayD RD8;
  TArrayD RD_f;

  TArrayD bl_gradient;// baseline gradient
  TArrayD bl_gradient2;
  TArrayD bl_gradient3;
  TArrayD bl_gradient4;
  TArrayD bl_gradient5;
  TArrayD bl_gradient6;
  TArrayD bl_gradient7;
  TArrayD bl_gradient8;
  TArrayD bl_gradient_f;

  TArrayD IOPH;//integral over pulse height
  TArrayD IOPH2;
  TArrayD IOPH3;
  TArrayD IOPH4;
  TArrayD IOPH5;
  TArrayD IOPH6;
  TArrayD IOPH7;
  TArrayD IOPH8;
  TArrayD IOPH_f;

  TArrayD RML; //right minus left
  TArrayD RML2;
  TArrayD RML3;
  TArrayD RML4;
  TArrayD RML5;
  TArrayD RML6;
  TArrayD RML7;
  TArrayD RML8;
  TArrayD RML_f;

  TArrayD TDOP;//Time difference over pulse height
  TArrayD TDOP2;
  TArrayD TDOP3;
  TArrayD TDOP4;
  TArrayD TDOP5;
  TArrayD TDOP6;
  TArrayD TDOP7;
  TArrayD TDOP8;
  TArrayD TDOP_f;

  Double_t para0;
  Double_t para1;
  Double_t para2;
  Double_t para3;
  Double_t para4;
  Double_t para5;
  Double_t para6;
  Double_t para7;
  Double_t para8;
  Double_t para9;
  Double_t para10;

  TArrayD parame0;  //parameter of the exponential fitted pulse height result
  TArrayD parame1;
  TArrayD parame2;
  TArrayD parame3;
  TArrayD parame4;
  TArrayD parame5;
  TArrayD parame6;
  TArrayD parame7;
  TArrayD parame8;
  TArrayD parame9;
  TArrayD parame10;

  TArrayD parame0_c;  //parameter of the exponential fitted pulse height result after chisquare cut
  TArrayD parame1_c;
  TArrayD parame2_c;
  TArrayD parame3_c;
  TArrayD parame4_c;
  TArrayD parame5_c;
  TArrayD parame6_c;
  TArrayD parame7_c;
  TArrayD parame8_c;
  TArrayD parame9_c;

  TArrayD Integral;  //integral of the pulse
  TArrayD Integral_c; //integral of the pulse after chisquare cut

  Double_t parame0_hp; //parameter of the template fitted pulse height result
  Double_t parame1_hp; //parameter of the template fitted pulse height result
  Double_t parame2_hp; //parameter of the template fitted pulse height result
  Double_t parame3_hp; //parameter of the template fitted pulse height result
  Double_t parame4_hp; //parameter of the template fitted pulse height result
  Double_t parame5_hp; //parameter of the template fitted pulse height result
  Double_t parame6_hp; //parameter of the template fitted pulse height result
  Double_t parame7_hp; //parameter of the template fitted pulse height result
  Double_t parame8_hp; //parameter of the template fitted pulse height result
  Double_t parame9_hp; //parameter of the template fitted pulse height result
  Double_t parame10_hp; //parameter of the template fitted pulse height result
  Double_t parame11_hp; //parameter of the template fitted pulse height result

  TArrayI maxpos; //position of maximum, that it should also be the position of the peak.
  TArrayD bl_off; //baseline offset;

  TArrayD TCP; //template construction pulses parameter

  TArrayD PP; //peak position in the events

  Int_t j=0; //start counter
  Double_t inte=0.0; //intergration value
  Double_t t_switch; // switch time, it is the time that the raw data change from positive to negative of the base value, or the opposite way.
  Double_t ts_left; //another switch time recorder. I need the difference of this two switch time to get a real time period of integration
  Int_t sc=0; //switching counter. The period of integration is every two switching counter.
  Int_t ndc=0; //counter of new data point after integration 
  Int_t recl(0);// record length
  Double_t per(0), off(0); // period and offset of the switching
  Double_t accu(0.0); //accumulator in the high pass filter
  Int_t n1;
  Int_t n2;
  Int_t n3;

  GetPeriod(DetName, EventList);

//  Int_t en=0;// total event number

  Int_t max_recl(1);
  TCPulse pls;
  TArrayD newyb, newtimeb;     //newyb stands for new y, (b) is only convention, after getting rid of those points near the switching. The same is new time b

  while ((e = static_cast<TCEvent*>(eit.Next())))//The idea is that, good event should have the largest record length, and rough event should have shorter record length
  {

    if(e->GetPulse(pls,DetNum))
    {
       if(pls.GetRecordLength()>max_recl)
       max_recl=pls.GetRecordLength();
    }

  }

  eit.Reset();

   while ((e = static_cast<TCEvent*>(eit.Next())))   //a loop over the event list
   {

//    en ++;

//    cout << "Event  " << e->GetEventNumber() << endl;

    TArrayD y; // this will be filled with the data points of each pulse
//    Double_t Base=0; // This is the baseline of the modulation

    Double_t baseline = 0;  //This is the baseline of the real voltage
    Int_t pret(0);

    if(e->GetPulse(pls,DetNum))
    {
    pls.GetTDData(y, baseline);
    pret = pls.GetPreTrigger();
    recl = pls.GetRecordLength();
    }

    Base = GetBase(y);

//Below is the high-pass filter. 
//Before performing filter, I need to combine different events, as longer data makes the high pass filter precision higher. 
//Also, I need to find out where the Daq doesn't work properly, at that point we need to break the chain.

//Firstly, I plan to work out what are the wrong records.

    if(pls.GetRecordLength()<max_recl) //those with a shorter record length are rough events
    {
    accu=0.0;
    }

    else 
   {
/*
   if(hp)  //we can choose whether or not perform high pass
   {

     TArrayD x; //temporary quantity of the high pass 
     pls.GetTDData(x, baseline);
     Double_t tc=60.0/(3.1415926*2.0); //In the units of milli seconds. The time const of the filter. If correct, the cut off frequency should be half of the modulation frequency.
     Double_t ex=exp(-timbas/tc);

     for(Int_t i=0;i<y.GetSize();i++)
     {
     x[i]=y[i]*(1.0-ex)+accu*ex;
     accu = x[i];
     }

     for(Int_t i=0;i<y.GetSize();i++)
     {
     y[i]=y[i]-x[i];
     }
//high pass end
   }
*/
      per =   pls.GetParameterValue(pmap[26]);
      off =   pls.GetParameterValue(pmap[25]);

      if (per/timbas < recl)         //recl is an Int, so I assume it is the digit number in the counting
      {
////////////////////////////here Junsong do the integration without getting rid of any data points/////////////////////
          j=0;
          inte=0.0;
          sc=0;
          ndc=0;

          while((y[j]-Base)*(y[j+1]-Base) > 0) j++;//So it gets to the first switching point. We dispose the first few data points before the first switching. Another thing needs to be considered is Base may change in long term. We need to calculate the Base for each event.

          //Dealing with the start point, I don't think it matters too much//
          ts_left =((Base-y[j])/(y[j+1]-y[j]))*timbas+j*timbas; //the first switch time. The starting point needs to be treated specially.
          inte = ((j+1)*timbas-ts_left)*TMath::Abs(y[j+1]-Base)/2.0; // allocate this area to the first integration.
          j++; //move it one more step for the counting issue.

           for (Int_t i=j ; i<y.GetSize()-1; i++)
          {
             if ((y[i]-Base)*(y[i+1]-Base) <= 0)         //Deal with the boundary. One draw back, if y[i]==0 here.
             {
                if (y[i]==0) sc--;           //avoid overcount of sc if y[i] or y[i+1]==0
                sc++;
                t_switch=((Base-y[i])/(y[i+1]-y[i]))*timbas+i*timbas;// In milli second

                if (sc==1)
                {
                newtimeb.Set(ndc+1);
                newtimeb[ndc]=t_switch; //In units of milli second
                inte = inte + ((t_switch-i*timbas)*TMath::Abs(Base-y[i]) + ((i+1)*timbas-t_switch)*TMath::Abs(y[i+1]-Base))/2.0; //triangle
                }

                if (sc==2)
                {
                newyb.Set(ndc+1);
                inte = inte + (t_switch-i*timbas)*TMath::Abs(Base-y[i])/2.0;  //triangle
                newyb[ndc]=inte/(t_switch-ts_left);

               //reset for the next integration
                ndc++;
                sc=0;//go down to  next integration
                inte = 0.0 + ((i+1)*timbas-t_switch)*TMath::Abs(y[i+1]-Base)/2.0; //allocate to the next integration
                ts_left=t_switch;// to set this as the new switch time
                }
             }

             else                                    //Non-boundary region, deal with by integrating with trapezoid method
            {
                inte = inte + timbas*(TMath::Abs(y[i]-Base)+TMath::Abs(y[i+1]-Base))/2.0;
            }
          }

    //flip around the baseline. The resistance decreases as the temperature increase (energy deposit, pulse)
    for (Int_t i=0; i<ndc; ++i)
    {
    newyb[i]=-1.0*newyb[i];
    }

    // Find maximum and minimum
    Double_t  traMin(10);
    Double_t  traMax(-10);
    Int_t posMax=0;

    Double_t  blOffset(0), mv(0);

    for (Int_t i=1; i<ndc; ++i) 
    {
      if (traMin > newyb[i]) traMin = newyb[i];

      if (traMax < newyb[i]) 
      {
	traMax = newyb[i];
	posMax = i;
      }
    }
    pls.SetParameterValue(traMin, pmap[22]);
    pls.SetParameterValue(traMax, pmap[23]);

    // Find the baseline offset by averaging over n (to be set) points. These n points are n successive points in the whole event. So there should be some time during which there are no pulses.
    Int_t basestart(1), basei(1);
    Double_t  rmsbase(10), rmsi(0), baseavg(0), avgi(0);
    Int_t n(30);

    while ((basei + n-1)<ndc)
    {
      avgi=0;
      for(Int_t i=basei; i<(basei+n); i++) avgi += newyb[i];
      avgi /= n;
      rmsi = 0;
      for(Int_t i=basei; i<(basei+n); i++) rmsi += (newyb[i]-avgi)*(newyb[i]-avgi);
      rmsi /= n;
      rmsi = TMath::Sqrt(rmsi);
      if (rmsi < rmsbase)
      {
	basestart = basei;
	rmsbase = rmsi;
	baseavg = avgi;
      }
      basei++;
    }

//    cout << "Baseline Offset is " << baseavg << " at " << newtimeb[basestart] << endl;

    bl_off.Set(e->GetEventNumber()+1);
    bl_off[e->GetEventNumber()]=baseavg;

    bRMS.Set(e->GetEventNumber()+1);
    bRMS[e->GetEventNumber()] = rmsbase;

    blOffset = baseavg;
    Double_t  amplitude = traMax - blOffset;        // Pulse Height [V]
    pls.SetParameterValue(blOffset, pmap[1]);
    pls.SetParameterValue(amplitude, pmap[2]);

    // Baseline RMS
    pls.SetParameterValue(rmsbase, pmap[20]);

    Int_t ln;//long event event number
    ln=long_event.GetSize();
    long_event.Set(ln+newyb.GetSize());
    for(Int_t i=0 ; i<newyb.GetSize(); i++)
    {
    long_event[ln+i]=newyb[i];
    }

/////////////////////////Very important and very easy to forget!//////////////

    // Find the pulse onset. This is when going left from the pulse maximum,
    // the onset disappears in the baseline noise.
    // To start with, return to the maximum; then continue sliding down
    // the pulse from its maximum.

    mv = 0;
    Int_t FillStart = (posMax < ndc) ? posMax : ndc;
    //    for (Int_t i=FillStart; i<FillStart+mvAvr; ++i) mv += y[i];
    //    onSet = Double_t (mvFillStart + mvAvr/2);int(
    Double_t  onSet = Double_t (FillStart);
    Double_t  Oncutoff = (blOffset+rmsbase);
    Int_t onSeti (0);
    for (Int_t i=FillStart-1; i>=0; --i) 
    {
      onSet = Double_t (newtimeb[i]);
      onSeti = i;
      if (newyb[i] < Oncutoff) break;
    }
    pls.SetParameterValue(onSet*timbas, pmap[4]);

//    cout << "rms " << rmsbase << " Max " << newtimeb[posMax] << " onSet " << onSet << endl;

//*********Understand**********//    
    // Find the 10-50 and 10-70 rise times by iterating back from peak
    // and the fall time by iterating forward 

    Double_t  p10 = 0.1 * amplitude + blOffset;     // absolute
    Double_t  p50 = 0.5 * amplitude + blOffset;     // absolute
    Double_t  p70 = 0.7 * amplitude + blOffset;     // absolute
    Double_t  p37 = 0.36788 * amplitude + blOffset; // absolute
    
    Int_t cPos = posMax;
    while (cPos > 0) if (newyb[cPos--] < p70) break;
    Int_t seventyPercent = (cPos+1);
    while (cPos > 0) if (newyb[cPos--] < p50) break;
    Int_t fiftyPercent = (cPos+1);
    while (cPos > 0) if (newyb[cPos--] < p10) break;                      //The sequence of -- and the [] may worth some consideration!!!!!!!!!!!!!!!!!!!
    Int_t tenPercent = (cPos + 1);
    pls.SetParameterValue((Double_t (newtimeb[fiftyPercent] - newtimeb[tenPercent])), pmap[5]);
    pls.SetParameterValue((Double_t (newtimeb[seventyPercent] - newtimeb[tenPercent])), pmap[6]);
    cPos = posMax;
    while (cPos < ndc) if (newyb[cPos++] < p37) break;                     // decay time
    pls.SetParameterValue((Double_t (newtimeb[cPos-1] - newtimeb[posMax])), pmap[7]);
//*********Understand**********//

    // Calculate a simple, complete integral
    Double_t  sum = 0;
    for (Int_t i=1; i<ndc; ++i) sum += newyb[i] - blOffset;
    Double_t  sci = (amplitude != 0) ? per * sum / amplitude : 0;  //sci stands for Integral divided over Pulse height. Also 2*per  ?
    //    Double_t  sci = 2*per*sum;
    pls.SetParameterValue(sci, pmap[13]);
//    cout << "Integral " << sci << endl;

    // Right minus left baseline taken over the width of the moving
    // average.

    sum = 0;
    for (Int_t i=1; i<n; ++i) sum += newyb[ndc-i-1] - newyb[i];
    Double_t  rml = (n > 0) ? sum/n : 0;
    //    sum += newy[jmax-1] - newy[0];
    pls.SetParameterValue(rml, pmap[9]);
  }
 }
}

/*
//high pass begin
if(hp)  //we can choose whether or not perform high pass
{
  Double_t accu(0.0);
  TArrayD x; //temporary quantity of the high pass 
  x.Set(long_event.GetSize());
  Double_t tc=60.0/(3.1415926*2.0); // The time const is the first number, the cut off frequency is the inverse of it.
  Double_t ex=exp(-per/tc);

  for(Int_t i=0;i<long_event.GetSize();i++)
  {
  x[i]=long_event[i]*(1.0-ex)+accu*ex;
  accu = x[i];
  }

  for(Int_t i=0;i<long_event.GetSize();i++)
  {
  long_event[i]=long_event[i]-x[i];
  }

}
//high pass end
*/

//TCanvas *c1 = new TCanvas("c1","long event",800,600);
TFile f1(fname,"RECREATE");
TGraph *Plot = new TGraph(long_event.GetSize());
Plot->SetName("Long Event");
for(Int_t i=0; i<long_event.GetSize();i++)
{
 Plot->SetPoint(i, i*per, long_event[i]);
}
Plot->Draw("AL");
Plot->Write();

//Analysis of the long event
eit.Reset();
e = static_cast<TCEvent*>(eit.Next());
Int_t event_no;
event_no=e->GetEventNumber();

n1=85/per; //so n1 stands for number of data point for 85 milli-seconds, it is the pretrigger region
n2=15/per;
n3=300/per;//region after the peak

Double_t baseavg(0.0);
Double_t rmsbase(0.0);

for(Int_t i=n1+n2; i<long_event.GetSize(); i++)
{
     Int_t n;
     n=event_no+Int_t(i/ndc); //it tells about which events is the data point in.

     baseavg = 0;
     for(Int_t i1=i-n2-n1; i1<i-n2; i1++) baseavg += long_event[i1];
     baseavg /= n1;
     rmsbase = 0;
     for(Int_t i1=i-n2-n1; i1<i-n2; i1++) rmsbase += (long_event[i1]-baseavg)*(long_event[i1]-baseavg);
     rmsbase /= n1;
     rmsbase = TMath::Sqrt(rmsbase);

     if((long_event[i] > (baseavg +9.0*rmsbase)))  //threshold value, we may want to set a different one afterwards.
     {
//        cout<<"event number:"<<n<<endl;
//        cout << pno << " start " << Double_t(per*i)<<" ms" <<endl;
//        cout <<"Baseline offset:"<<baseavg<<endl;
        Double_t Max(-10);
        Int_t posiMax(i);

        for (Int_t j1=i; j1<long_event.GetSize(); j1++) 
        {
          if (Max < long_event[j1])
          {
            Max = long_event[j1];
            posiMax = j1;
          }

          if ((long_event[j1] < baseavg + 5.0*rmsbase)||(j1>posiMax+n3))// to adjust for this is because in the large pulses, 1/e times the amplitude may still larger than the trigger. That is why we need to let it settle back to the baseline before going to next pulse
//one thing that can be improved, that those pulses in n3*per time never settle back to the baseline. It may be due to rising baseline(we can accept), or it is different pulses type(we want to discriminate this kind of pulses)
          {


           if((posiMax+n3)<long_event.GetSize())
           {

//           c = new TCanvas;
/*            TGraph *Plot2 = new TGraph(j1-(i-n2-n1));

            for (Int_t i1= i-n2-n1; i1<j1; i1++)
            {
             Plot2->SetPoint(i1-(i-n2-n1), i1*per, long_event[i1]);
            }
*/
            for(Int_t i1=posiMax; i1<posiMax+n3; i1++)
            {
             if (long_event[i1] < (baseavg + 0.367879*(Max-baseavg)))//decay back, the definition of decay time, the time decay back to 1/e of the pulse height. This can be improved if we can get the pulse shape fit, and then extract the decay time from the pulse shape. Right now the precision is constrained by the modulation time.
             {
              decayts.Set(pno+1);
              decayts[pno] = i1*per - posiMax*per;
              break;
             }
            }

            for(Int_t l=posiMax;l>=posiMax-n2;l--)
            {
              if(long_event[l] < baseavg+0.367879*(Max-baseavg))
              {
	      risets.Set(pno+1);
	      risets[pno] = posiMax*per-l*per;
              break;
              }

              if(l==posiMax-n2)  //if the rise time is more than n2*per, we need to set it to the n2*per
              {
              risets.Set(pno+1);
	      risets[pno] = posiMax*per-l*per;
              }
            }

          //below I will investigate the pulse height ratio to see if there is any pile up
           Double_t local_vmin(Max);
           Double_t Dmax(0.0);
           Double_t Di(0.0);

           for(Int_t i1=posiMax;i1<posiMax+n3;i1++)  //forward
           {
             if(long_event[i1]<local_vmin)
             {
              local_vmin=long_event[i1];
             }

             Di=long_event[i1]-local_vmin;

             if(Di>Dmax)
             {
             Dmax=Di;
             }
           }

          local_vmin=Max;  //reset for the backward

           for(Int_t i1=posiMax;i1>posiMax-(n1+n2);i1--)//backward
          {
            if(long_event[i1]<local_vmin)
            {
             local_vmin=long_event[i1];
            }

             Di=long_event[i1]-local_vmin;

            if(Di>Dmax)
            {
            Dmax=Di;
            }
          }

            RD.Set(pno+1);
            RD[pno]=Dmax/rmsbase;


            Double_t par[2];
            Int_t ifail;
            Plot->LeastSquareLinearFit(n1,par[0],par[1],ifail,(posiMax-n2-n1)*per,(posiMax-n2)*per);
//           cout<<"Fit is OK if ifail==0, ifail:"<<ifail<<endl;
            bl_gradient.Set(pno+1);
            bl_gradient[pno] = par[1];

            b_RMS.Set(pno+1);
            for(Int_t i1=posiMax-n2-n1; i1<posiMax-n2; i1++) b_RMS[pno] += (long_event[i1]-(par[0]+i1*per*par[1]))*(long_event[i1]-(par[0]+i1*per*par[1]));
            b_RMS[pno] /= n1;
            b_RMS[pno] = TMath::Sqrt(b_RMS[pno]);

            times.Set(pno+1);
            times[pno] =posiMax*per; //In the unit of milli second now

            ntime.Set(pno+1);
